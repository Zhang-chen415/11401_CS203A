# Graph (圖)

圖 (Graph) 是一種強大的非線性資料結構，用於表示物件（頂點）與其之間的關係（邊）。它是模擬社交網路、地圖導航、電路設計以及網際網路結構的核心基礎。

---

## 1. 核心定義：$G = (V, E)$

圖是由一組頂點與一組邊所組成的集合，通常表示為 $G = (V, E)$。

* **V (Vertex / Node)**：頂點，代表資料實體。
* **E (Edge / Arc)**：邊，代表兩個頂點之間的連接關係。



---

## 2. 圖的分類 (Graph Types)

根據邊的特性，圖可以分為多種類型：

| 類型 | 特點 | 範例 |
| :--- | :--- | :--- |
| **無向圖 (Undirected)** | 邊沒有方向，(A, B) 等同於 (B, A)。 | 臉書的好友關係 |
| **有向圖 (Directed)** | 邊有方向性，由起點指向終點。 | Twitter/IG 的追蹤關係 |
| **加權圖 (Weighted)** | 每條邊都帶有一個數值（權重）。 | 地圖上的距離、交通成本 |
| **無權圖 (Unweighted)** | 邊僅表示存在關係，權重均為 1。 | 簡單的連通性測試 |
| **循環圖 (Cyclic)** | 圖中存在至少一條路徑可繞回原點。 | 交通環島、循環引用 |
| **無環圖 (Acyclic)** | 圖中不存任何迴圈 (Cycle)。 | 家族譜系、DAG (有向無環圖) |



---

## 3. 圖的表示法 (Representations)

在記憶體中儲存圖主要有兩種主流方式，各自有其優缺點：

### 3.1 相鄰矩陣 (Adjacency Matrix)
使用二維陣列 `adj[V][V]` 儲存。若 $V_i$ 到 $V_j$ 有邊，則 `adj[i][j] = 1`（或其權重）。
* **優點**：查詢兩點是否有邊極快 ($O(1)$)。
* **缺點**：空間複雜度高 ($O(V^2)$)，對「稀疏圖」非常浪費空間。

### 3.2 相鄰串列 (Adjacency List)
每個頂點維護一個鏈結串列或動態陣列，紀錄其相鄰的頂點。
* **優點**：節省空間 ($O(V + E)$)，遍歷鄰居節點效率高。
* **缺點**：查詢特定兩點是否有邊較慢 ($O(V)$)。

[Image comparison between adjacency matrix and adjacency list]

---

## 4. 圖的走訪 (Traversal)

遍歷圖是許多演算法（如尋找路徑、檢查連通性）的基礎：

### 廣度優先搜尋 (BFS, Breadth-First Search)
* **策略**：先廣後深，逐層探索相鄰頂點。
* **工具**：**Queue (佇列)**。
* **應用**：尋找「無權圖」中的**最短路徑**。

### 深度優先搜尋 (DFS, Depth-First Search)
* **策略**：一條路走到底，直到不能再前進再回溯。
* **工具**：**Stack (堆疊)** 或 **遞迴**。
* **應用**：檢查是否有環、拓撲排序、強連通分量。



---

## 5. 時間複雜度分析 (以相鄰串列為準)

| 操作 | 複雜度 | 說明 |
| :--- | :---: | :--- |
| **空間複雜度** | $O(V + E)$ | 頂點與邊的總和 |
| **BFS 走訪** | $O(V + E)$ | 每個頂點與邊皆走訪一次 |
| **DFS 走訪** | $O(V + E)$ | 每個頂點與邊皆走訪一次 |
| **查詢兩點是否有邊** | $O(V)$ | 需檢查該點的相鄰串列 |

---

## 6. 程式碼實作範例 (C++)

```cpp
#include <iostream>
#include <vector>
#include <list>

class Graph {
    int V; // 頂點總數
    std::vector<std::list<int>> adj; // 使用相鄰串列

public:
    Graph(int V) : V(V) {
        adj.resize(V);
    }

    // 新增邊 (無向圖)
    void addEdge(int v, int w) {
        adj[v].push_back(w);
        adj[w].push_back(v);
    }

    // 印出圖的相鄰串列
    void printGraph() {
        for (int i = 0; i < V; ++i) {
            std::cout << "Vertex " << i << " neighbors: ";
            for (int x : adj[i]) std::cout << x << " ";
            std::cout << std::endl;
        }
    }
};
```

---

## 7. 實際應用

- GPS 導航：計算最短行車路徑。
- 社交推薦：分析「共同好友」或「你可能感興趣的人」。
- 垃圾郵件偵測：分析郵件發送者的關聯網路。
- 編譯器優化：分析程式碼中的變數相依圖。
