# Stack & Queue

在資料結構中，Stack 與 Queue 稱為「受限線性結構」，因為它們不像 Array 或 Linked List 可以隨意存取任何位置的元素，而是必須遵循特定的進出規則。

---

## 1. Stack (堆疊) - LIFO 結構

Stack 是一種 **後進先出 (Last-In, First-Out)** 的資料結構。最後進入 Stack 的元素，會最先被移除。



### 1.1 抽象資料型態操作
* **Push(data)**: 將資料壓入堆疊頂端。
* **Pop()**: 移出堆疊頂端的資料。若堆疊為空，會發生 **Underflow**。
* **Peek / Top**: 回傳頂端資料但不移除。
* **isEmpty**: 判斷堆疊是否為空。
* **isFull**: (僅限陣列實作) 判斷堆疊是否已滿，否則會發生 **Overflow**。

### 1.2 核心原理與實作
Stack 通常維護一個指標 `top`。
* **Array 實作**: `top` 初始為 -1，Push 時 `top++`，Pop 時 `top--`。存取速度快但大小固定。
* **Linked List 實作**: 始終在串列的 `Head` 進行插入與刪除。大小動態，但需要額外的指標空間。

### 1.3 深度應用場景
1.  **運算式求值**：將中序運算式轉為後序，並計算結果。
2.  **函數呼叫**：編譯器使用 Stack 紀錄程式執行路徑，實現遞迴。
3.  **語法檢查**：檢查 HTML 標籤是否閉合或括號是否成對。
4.  **回溯法**：如迷宮尋路。



---

## 2. Queue (佇列) - FIFO 結構

Queue 是一種 **先進先出 (First-In, First-Out)** 的資料結構。就像排隊一樣，先加入的元素先被處理。



### 2.1 核心操作與指標
Queue 維護兩個關鍵指標：
* **Front (頭)**: 指向第一個元素，用於 Dequeue 操作。
* **Rear (尾)**: 指向最後一個元素，用於 Enqueue 操作。

### 2.2 進階變體
1.  **Circular Queue (環狀佇列)**：
    使用陣列實作時，若不斷 Dequeue，前端空間會閒置。環狀佇列利用模運算 (Modulo `%`) 讓 `Rear` 繞回陣列開頭，實現空間循環利用。
    * 計算公式：`(rear + 1) % size`
    

2.  **Deque (雙端佇列)**：
    允許在 Front 和 Rear 兩端同時進行插入與刪除。
3.  **Priority Queue (優先權佇列)**：
    元素出列順序依據「優先級」而非進場順序。底層通常使用 **Binary Heap (二元堆積)** 實作。

### 2.3 應用實例
1.  **非同步資料傳輸**：如 IO 緩衝區、管線 (Pipe)。
2.  **資源排程**：CPU 的工作排程、印表機列印佇列。
3.  **圖論演算法**：廣度優先搜尋 (BFS) 的核心組件。

---

## 3. 效能對比與總結

### 3.1 時間複雜度 (Big O)
| 操作 | Stack | Queue | 備註 |
| :--- | :---: | :---: | :--- |
| **插入 (Push/Enqueue)** | $O(1)$ | $O(1)$ | 極高效率 |
| **刪除 (Pop/Dequeue)** | $O(1)$ | $O(1)$ | 極高效率 |
| **搜尋 (Search)** | $O(n)$ | $O(n)$ | 不建議在此結構進行搜尋 |
| **存取 (Access)** | $O(n)$ | $O(n)$ | 僅能存取頂端或頭部 |

### 3.2 實作選擇建議
* **需要極致速度且數量已知**：使用 **Array-based** 實作。
* **資料量波動劇烈且無法預期**：使用 **Linked List-based** 實作。
